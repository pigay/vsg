/* -*- C -*- */
%%
/* LIBVSG - Visaurin Geometric Library
 * Copyright (C) 2006-2008 Pierre Gay
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/*****************************************************************************/
%%
headers
#include "vsg/vsgprtree3@t@.h"
#include "vsg/vsgprtree3@t@-extras.h"
#include "vsg/vsgprtree3@t@-private.h"
#include "pyvsg_boxed_pyobject.h"

/*****************************************************************************/
%%
ignore
  vsg_prtree3@t@_new_full
  vsg_prtree3@t@_set_children_order_with_data

/*****************************************************************************/
%%
ignore-glob
  vsg_prtree3@t@_*_marshall
  
/*****************************************************************************/
%%
override-slot VsgPRTree3@t@.tp_flags

#define _wrap_vsg_prtree3@t@_tp_flags \
Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC

/*****************************************************************************/
%%
override-slot VsgPRTree3@t@.tp_init

static PyObject *pyvsg_point3@t@_locfunc (PyObject *candidate,
                                            VsgVector3@t@ *center,
                                            PyObject *point_locfunc)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);
  PyObject *pycenter = pyg_boxed_new(VSG_TYPE_VECTOR3@T@, center, FALSE,
                                     FALSE);

  Py_INCREF (candidate); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 0, candidate);
  PyTuple_SetItem (args, 1, pycenter);

  pyret = PyObject_CallObject (point_locfunc, args);

  Py_DECREF(args); /* will decref items */

  return pyret;
}

static vsgloc3 marshall_point_locfunc_3@t@ (PyObject *candidate,
                                              VsgVector3@t@ *center,
                                              PyObject *point_locfunc)
{
  vsgloc3 ret;
  PyObject *pyret;

  pyret = pyvsg_point3@t@_locfunc (candidate, center, point_locfunc);

  ret = (vsgloc3) PyInt_AsLong (pyret);

  Py_DECREF(pyret);

  return ret;
}

static PyObject *pyvsg_point3@t@_distfunc (PyObject *one,
                                             PyObject *other,
                                             PyObject *point_distfunc)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);

  Py_INCREF (one); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 0, one);
  Py_INCREF (other); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 1, other);

  pyret = PyObject_CallObject (point_distfunc, args);

  Py_DECREF(args); /* will decref items */

  return pyret;
}

static gdouble marshall_point_distfunc_3@t@ (PyObject *one,
                                               PyObject *other,
                                               PyObject *point_distfunc)
{
  gdouble ret;
  PyObject *pyret;

  pyret = pyvsg_point3@t@_distfunc (one, other, point_distfunc);

  ret = (gdouble) PyFloat_AsDouble (pyret);

  Py_DECREF(pyret);

  return ret;
}

static PyObject *pyvsg_region3@t@_locfunc (PyObject *candidate,
                                          VsgVector3@t@ *center,
                                          PyObject *point_locfunc)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);
  PyObject *pycenter = pyg_boxed_new(VSG_TYPE_VECTOR3@T@, center, FALSE,
                                     FALSE);

  Py_INCREF (candidate); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 0, candidate);
  PyTuple_SetItem (args, 1, pycenter);

  pyret = PyObject_CallObject (point_locfunc, args);

  Py_DECREF(args); /* will decref items */

  return pyret;
}

static vsgrloc3 marshall_region_locfunc_3@t@ (PyObject *candidate,
                                             VsgVector3@t@ *center,
                                             PyObject *region_locfunc)
{
  vsgloc3 ret;
  PyObject *pyret;

  pyret = pyvsg_region3@t@_locfunc (candidate, center, region_locfunc);

  ret = (vsgrloc3) PyInt_AsLong (pyret);

  Py_DECREF(pyret);

  return ret;
}

static int
_wrap_vsg_prtree3@t@_tp_init (PyGBoxed *self, PyObject *args,
                               PyObject *kwargs)
{
    static char *kwlist[] = { "lbound", "ubound", "point_locfunc",
                              "point_distfunc", "region_locfunc",
                              "max_point", NULL };
    PyObject *lbound, *ubound, *point_locfunc, *point_distfunc,
      *region_locfunc;
    guint max_point;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!O!OOOI:VsgPRTree3@t@.__init__",
                                     kwlist,
                                     &PyVsgVector3@t@_Type, &lbound,
                                     &PyVsgVector3@t@_Type, &ubound,
                                     &point_locfunc, &point_distfunc,
                                     &region_locfunc, &max_point))
      return -1;

    if (! PyCallable_Check (point_locfunc))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.__init__ point_locfunc argument " \
                        "must be a callable type");
        return -1;
      }
    if (! PyCallable_Check (point_distfunc))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.__init__ point_distfunc argument " \
                        "must be a callable type");
        return -1;
      }
    if (! PyCallable_Check (region_locfunc) && region_locfunc != Py_None)
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.__init__ region_locfunc argument " \
                        "must be a callable type");
        return -1;
      }

    self->gtype = VSG_TYPE_PRTREE3@T@;
    self->free_on_dealloc = FALSE;
    self->boxed =
      vsg_prtree3@t@_new_full (pyg_boxed_get (lbound, VsgVector3@t@),
                                pyg_boxed_get (ubound, VsgVector3@t@),
                                (VsgPoint3@t@LocFunc) 1, /* awful hack */
                                NULL, NULL, max_point);

    if (!self->boxed)
      {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create VsgPRTree3@t@ object");
        return -1;
      }

    Py_INCREF (point_locfunc);
    vsg_prtree3@t@_set_point_loc_marshall
      (self->boxed,
       (VsgPoint3@t@LocMarshall) marshall_point_locfunc_3@t@,
       point_locfunc);

    Py_INCREF (point_distfunc);
    vsg_prtree3@t@_set_point_dist_marshall
      (self->boxed,
       (VsgPoint3@t@DistMarshall) marshall_point_distfunc_3@t@,
       point_distfunc);

    if (region_locfunc != Py_None)
      {
        Py_INCREF (region_locfunc);
        vsg_prtree3@t@_set_region_loc_marshall
          (self->boxed,
           (VsgRegion3@t@LocMarshall) marshall_region_locfunc_3@t@,
           region_locfunc);
      }

    self->free_on_dealloc = TRUE;
    return 0;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_set_children_order

static void children_order_marshall3@t@ (gpointer node_key, gint *children,
                                         gpointer *children_keys,
                                         PyObject *func)
{
  PyObject *pynode_key = Py_BuildValue ("i", GPOINTER_TO_INT (node_key));
  PyObject *children_list = Py_BuildValue ("[i, i, i, i, i, i, i, i]",
                                           0, 0, 0, 0, 0, 0, 0, 0);
  PyObject *children_keys_list = Py_BuildValue ("[i, i, i, i, i, i, i, i]",
                                                0, 0, 0, 0, 0, 0, 0, 0);
  PyObject *ret;
  gint i;

  ret = PyObject_CallFunctionObjArgs (func, pynode_key, children_list,
                                      children_keys_list, NULL);

  if (ret != NULL)
    {
      Py_DECREF (ret);

      for (i=0; i<8; i++)
        {
          PyObject *pychildren = PyList_GetItem (children_list, i);
          PyObject *pychildren_key = PyList_GetItem (children_keys_list, i);

          children[i] = (gint) PyInt_AsLong (pychildren);
          children_keys[i] =
            GINT_TO_POINTER ((gint) PyInt_AsLong (pychildren_key));
        }
    }
  else
    {
      PyErr_Print();

      /* fallback to Z-order */
      for (i=0; i<8; i++)
        {
          children[i] = i;
          children_keys[i] = node_key;
        }
    }

  Py_DECREF (pynode_key);
  Py_DECREF (children_list);
  Py_DECREF (children_keys_list);
}

/**
 * vsg_prtree3@t@_set_children_order :
 * @children_order: a function for defining children order in traversals.
 * @root_key: the key to pass to @children_order for the first (root) node.
 *
 * Configures @self to use @children_order for determining children order
 * in traversals. If @children_order is set to %None, children ordering returns
 * to the default Z-order.
 *
 * Function @children_order must accept three arguments @node_key, @children and
 * @children_keys that are respectively an integer and two lists of size 8.
 * @root_key must also be an integer key.
 *
 */
static PyObject *
_wrap_vsg_prtree3@t@_set_children_order (PyObject *self, PyObject *args)
{
  PyObject *children_order;
  PyObject *root_key;

  if (!PyArg_ParseTuple(args, "OO:VsgPRTree3@t@.set_children_order",
                        &children_order, &root_key))
      return NULL;
  if (children_order == Py_None)
    {
      if (pyg_boxed_get (self, VsgPRTree3@t@)->config.children_order != NULL)
        {
          PyObject *old_func =
            pyg_boxed_get (self, VsgPRTree3@t@)->config.children_order_data;

          Py_DECREF (old_func);
        }

      vsg_prtree3@t@_set_children_order_with_data (pyg_boxed_get (self, VsgPRTree3@t@),
                                                   (VsgChildrenOrderDataFunc) NULL,
                                                   NULL, NULL);

    }
  else
    {
      gint rk;

      if (!PyCallable_Check(children_order))
        {
          PyErr_SetString(PyExc_TypeError,
                          "children_order must be a callable object or None");
          return NULL;
        }
      if (!PyNumber_Check(root_key))
        {
          PyErr_SetString(PyExc_TypeError,
                          "root_key must be an integer");
          return NULL;
        }

      rk = (gint) PyInt_AsLong (root_key);

      Py_INCREF (children_order);

      vsg_prtree3@t@_set_children_order_with_data (pyg_boxed_get (self, VsgPRTree3@t@),
                                                   (VsgChildrenOrderDataFunc) children_order_marshall3@t@,
                                                   GINT_TO_POINTER (rk),
                                                   children_order);
    }

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_insert_point

static PyObject *pyvsg_point3@t@_locfunc (PyObject *candidate,
                                            VsgVector3@t@ *center,
                                            PyObject *point_locfunc);

static PyObject *
_wrap_vsg_prtree3@t@_insert_point (PyObject *self, PyObject *args)
{
  PyObject *point;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.insert_point", &point))
      return NULL;

  test = pyvsg_point3@t@_locfunc (point, &testv,
                                    pyg_boxed_get (self, VsgPRTree3@t@)->config.point_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.insert_point argument must follow " \
                      "vsg.Point3@t@ interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  Py_INCREF (point);
  vsg_prtree3@t@_insert_point (pyg_boxed_get (self, VsgPRTree3@t@),
                                  point);

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_remove_point

static PyObject *
_wrap_vsg_prtree3@t@_remove_point (PyObject *self, PyObject *args)
{
  PyObject *point;
  gboolean removed;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.remove_point", &point))
      return NULL;

  test = pyvsg_point3@t@_locfunc (point, &testv,
                                    pyg_boxed_get (self, VsgPRTree3@t@)->config.point_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.remove_point argument must follow " \
                      "vsg.Point3@t@ interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  removed =
    vsg_prtree3@t@_remove_point (pyg_boxed_get (self, VsgPRTree3@t@),
                                    point);

  if (removed)
    {
      Py_DECREF (point);
      return Py_BuildValue ("i", 1);
    }

  return Py_BuildValue ("i", 0);
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_insert_region

static PyObject *pyvsg_region3@t@_locfunc (PyObject *candidate,
                                          VsgVector3@t@ *center,
                                          PyObject *point_locfunc);

static PyObject *
_wrap_vsg_prtree3@t@_insert_region (PyObject *self, PyObject *args)
{
  PyObject *region;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.insert_region", &region))
      return NULL;

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data == NULL)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.insert_region must be called on a tree " \
                      "that possesses a region_locfunc method.");
      return NULL;;
    }

  test = pyvsg_region3@t@_locfunc (region, &testv,
                                  pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.insert_region argument must follow " \
                      "vsg.Region3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  Py_INCREF (region);
  vsg_prtree3@t@_insert_region (pyg_boxed_get (self, VsgPRTree3@t@),
                                region);

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_remove_region

static PyObject *
_wrap_vsg_prtree3@t@_remove_region (PyObject *self, PyObject *args)
{
  PyObject *region;
  gboolean removed;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.remove_region", &region))
      return NULL;

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data == NULL)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.remove_region must be called on a tree " \
                      "that possesses a region_locfunc method.");
      return NULL;;
    }

  test = pyvsg_region3@t@_locfunc (region, &testv,
                                  pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.remove_region argument must follow " \
                      "vsg.Region3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  removed =
    vsg_prtree3@t@_remove_region (pyg_boxed_get (self, VsgPRTree3@t@),
                                  region);

  if (removed)
    {
      Py_DECREF (region);
      return Py_BuildValue ("i", 1);
    }

  return Py_BuildValue ("i", 0);
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_find_point

static PyObject *
_wrap_vsg_prtree3@t@_find_point (PyObject *self, PyObject *args)
{
  PyObject *selector;
  PyObject *result;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.find_point", &selector))
    return NULL;

  test = pyvsg_point3@t@_locfunc (selector, &testv,
                                    pyg_boxed_get (self, VsgPRTree3@t@)->config.point_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.find_point argument must follow " \
                      "vsg.Point3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  result = (PyObject *)
    vsg_prtree3@t@_find_point (pyg_boxed_get (self, VsgPRTree3@t@),
                                  selector);

  if (result != NULL)
    {
      Py_INCREF (result);
      return result;
    }

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_foreach_point

typedef struct _ForeachPointData3@t@ ForeachPointData3@t@;
struct _ForeachPointData3@t@ {
  PyObject *func;
  PyObject *user_data;
  gboolean success;
};

static void
_prtree3@t@_foreach_point_marshall (PyObject *point,
                                       ForeachPointData3@t@ *marshall_data)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);

  Py_INCREF (point); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 0, point);
  Py_INCREF (marshall_data->user_data);
  PyTuple_SetItem (args, 1, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->func, args);

  Py_DECREF(args); /* will decref point and marshall_data->user_data */

  if (pyret != NULL)
    {
      Py_DECREF(pyret); /* pyret should be None: let's ignore it*/
    }
  else
    marshall_data->success = FALSE; /* an error occurred */
}

static PyObject *
_wrap_vsg_prtree3@t@_foreach_point (PyObject *self, PyObject *args)
{
  PyObject *func, *user_data;
  ForeachPointData3@t@ marshall_data;

  if (!PyArg_ParseTuple(args, "OO:VsgPRTree3@t@.foreach_point", &func,
                        &user_data))
    return NULL;

  if (! PyCallable_Check (func))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.foreach_point func argument " \
                        "must be a callable type");
        return NULL;
      }

  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  vsg_prtree3@t@_foreach_point (pyg_boxed_get (self, VsgPRTree3@t@),
                                   (GFunc) _prtree3@t@_foreach_point_marshall,
                                   &marshall_data);

  if (!marshall_data.success) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_foreach_point_custom

typedef struct _ForeachPointCustomData3@t@ ForeachPointCustomData3@t@;
struct _ForeachPointCustomData3@t@ {
  PyObject *selector;
  PyObject *locfunc;
  PyObject *func;
  PyObject *user_data;
  gboolean success;
};

static void
_prtree3@t@_foreach_point_custom (const VsgPRTree3@t@NodeInfo *node_info,
                                     ForeachPointCustomData3@t@ *marshall_data)
{
  GSList *point_list = node_info->point_list;

  while (point_list)
    {
      PyObject *point = (PyObject *) point_list->data;
      PyObject *pylocret;
      PyObject *locargs = PyTuple_New (2);
      vsgrloc3 locret;

      /* since PyTuple_SetItem steals a reference on item, we incref them */
      Py_INCREF (marshall_data->selector);
      PyTuple_SetItem (locargs, 0, marshall_data->selector);
      Py_INCREF (point);
      PyTuple_SetItem (locargs, 1, point);

      pylocret = PyObject_CallObject (marshall_data->locfunc, locargs);

      Py_DECREF(locargs); /* will decref items */

      if (pylocret == NULL || !PyInt_Check(pylocret)) /* an error occurred */
        {
          marshall_data->success = FALSE;
          return;
        }

      locret = (vsgrloc3) PyInt_AsLong (pylocret);
      Py_DECREF (pylocret);

      if (locret == VSG_RLOC3_MASK)
        {
          PyObject *pyfuncret;
          PyObject *funcargs = PyTuple_New (2);

          /* since PyTuple_SetItem steals a reference on item, we incref them */
          Py_INCREF (point);
          PyTuple_SetItem (funcargs, 0, point);
          Py_INCREF (marshall_data->user_data);
          PyTuple_SetItem (funcargs, 1, marshall_data->user_data);

          pyfuncret = PyObject_CallObject (marshall_data->func, funcargs);

          Py_DECREF(funcargs); /* will decref items */

          if (pyfuncret != NULL)
            {
              Py_DECREF(pyfuncret); /* pyret should be None: let's ignore it*/
            }
          else
            {
              marshall_data->success = FALSE; /* an error occurred */
              return;
            }
        }

      point_list = g_slist_next (point_list);
    }
}

static PyObject *
_wrap_vsg_prtree3@t@_foreach_point_custom (PyObject *self, PyObject *args)
{
  PyObject *selector, *locfunc;
  PyObject *func, *user_data;
  ForeachPointCustomData3@t@ marshall_data;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "OOOO:VsgPRTree3@t@.foreach_point_custom",
                        &selector, &locfunc,
                        &func, &user_data))
    return NULL;

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data == NULL)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.foreach_point_custom must be called on a tree " \
                      "that possesses a region_locfunc method.");
      return NULL;;
    }

  test = pyvsg_region3@t@_locfunc (selector, &testv,
                                  pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.foreach_point_custom selector " \
                      "argument must follow vsg.Region3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}


  if (! PyCallable_Check (locfunc))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.foreach_point_custom locfunc " \
                        "argument must be a callable type");
        return NULL;
      }

  if (! PyCallable_Check (func))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.foreach_point_custom func " \
                        "argument must be a callable type");
        return NULL;
      }

  marshall_data.selector = selector;
  marshall_data.locfunc = locfunc;
  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  /* we emulate foreach_point_custom */
  vsg_prtree3@t@_traverse_custom (pyg_boxed_get (self, VsgPRTree3@t@),
                                   G_POST_ORDER,
                                   (VsgPoint3) selector,
                                   (VsgPRTree3@t@Func) _prtree3@t@_foreach_point_custom,
                                   (gpointer) &marshall_data);

  if (!marshall_data.success) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_foreach_region

typedef struct _ForeachRegionData3@t@ ForeachRegionData3@t@;
struct _ForeachRegionData3@t@ {
  PyObject *func;
  PyObject *user_data;
  gboolean success;
};

static void
_prtree3@t@_foreach_region_marshall (PyObject *region,
                                       ForeachRegionData3@t@ *marshall_data)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);

  Py_INCREF (region); /* since PyTuple_SetItem steals a reference on item */
  PyTuple_SetItem (args, 0, region);
  Py_INCREF (marshall_data->user_data);
  PyTuple_SetItem (args, 1, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->func, args);

  Py_DECREF(args); /* will decref point and marshall_data->user_data */

  if (pyret != NULL)
    {
      Py_DECREF(pyret); /* pyret should be None: let's ignore it*/
    }
  else
    marshall_data->success = FALSE;
}

static PyObject *
_wrap_vsg_prtree3@t@_foreach_region (PyObject *self, PyObject *args)
{
  PyObject *func, *user_data;
  ForeachRegionData3@t@ marshall_data;

  if (!PyArg_ParseTuple(args, "OO:VsgPRTree3@t@.foreach_region", &func,
                        &user_data))
    return NULL;


  if (! PyCallable_Check (func))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.foreach_region func argument " \
                        "must be a callable type");
        return NULL;
      }

  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  vsg_prtree3@t@_foreach_region (pyg_boxed_get (self, VsgPRTree3@t@),
                                   (GFunc) _prtree3@t@_foreach_region_marshall,
                                   &marshall_data);

  if (!marshall_data.success) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_foreach_region_custom

typedef struct _ForeachRegionCustomData3@t@ ForeachRegionCustomData3@t@;
struct _ForeachRegionCustomData3@t@ {
  PyObject *selector;
  PyObject *func;
  PyObject *user_data;
  gboolean success;
};

static void
_prtree3@t@_foreach_region_custom (const VsgPRTree3@t@NodeInfo *node_info,
                                   ForeachRegionCustomData3@t@ *marshall_data)
{
  GSList *region_list = node_info->region_list;

  while (region_list)
    {
      PyObject *region = region_list->data;
      PyObject *pyfuncret;
      PyObject *funcargs = PyTuple_New (2);

      /* since PyTuple_SetItem steals a reference on item, we incref them */
      Py_INCREF (region);
      PyTuple_SetItem (funcargs, 0, region);
      Py_INCREF (marshall_data->user_data);
      PyTuple_SetItem (funcargs, 1, marshall_data->user_data);

      pyfuncret = PyObject_CallObject (marshall_data->func, funcargs);

      Py_DECREF(funcargs); /* will decref items */

      if (pyfuncret != NULL)
        {
          Py_DECREF(pyfuncret); /* pyret should be None: let's ignore it*/
        }
      else
        {
          marshall_data->success = FALSE; /* an error occurred */
          return;
        }

      region_list = g_slist_next (region_list);
    }
}

static PyObject *
_wrap_vsg_prtree3@t@_foreach_region_custom (PyObject *self, PyObject *args)
{
  PyObject *selector;
  PyObject *func, *user_data;
  ForeachRegionCustomData3@t@ marshall_data;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "OOO:VsgPRTree3@t@.foreach_region_custom",
                        &selector, &func, &user_data))
    return NULL;

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data == NULL)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.foreach_region_custom must be called on a tree " \
                      "that possesses a region_locfunc method.");
      return NULL;;
    }

  test = pyvsg_region3@t@_locfunc (selector, &testv,
                                  pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.foreach_region_custom selector " \
                      "argument must follow vsg.Region3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}

  if (! PyCallable_Check (func))
      {
        PyErr_SetString(PyExc_ValueError,
                        "VsgPRTree3@t@.foreach_region func argument " \
                        "must be a callable type");
        return NULL;
      }

  marshall_data.selector = selector;
  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  /* we emulate foreach_region_custom */
  vsg_prtree3@t@_traverse_custom (pyg_boxed_get (self, VsgPRTree3@t@),
                                   G_POST_ORDER,
                                   (VsgRegion3) selector,
                                   (VsgPRTree3@t@Func) _prtree3@t@_foreach_region_custom,
                                   (gpointer) &marshall_data);

  if (!marshall_data.success) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_find_deep_region

typedef struct _FindDeepRegionData3@t@ FindDeepRegionData3@t@;

struct _FindDeepRegionData3@t@
{
  PyObject *check;
  PyObject *user_data;
  gboolean success;
};

static gboolean
 _prtree3@t@_find_deep_region_marshall (PyObject *region,
                                        FindDeepRegionData3@t@ *marshall_data)
{
  PyObject *pyret;
  PyObject *args = PyTuple_New (2);
  gint ret;

  /* since PyTuple_SetItem steals a reference on item, we incref them */
  Py_INCREF (region);
  PyTuple_SetItem (args, 0, region);
  Py_INCREF (marshall_data->user_data);
  PyTuple_SetItem (args, 1, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->check, args);

  Py_DECREF(args); /* will decref items */

  ret = PyObject_IsTrue (pyret);

  Py_DECREF (pyret);

  if (ret < 0)
    {
      marshall_data->success = FALSE;
      return FALSE;
    }

  return (gboolean) ret;
}

static PyObject *
_wrap_vsg_prtree3@t@_find_deep_region (PyObject *self, PyObject *args)
{
  PyObject *region, *point, *check, *user_data;

  if (!PyArg_ParseTuple(args, "OOO:VsgPRTree3@t@.find_deep_region",
                        &point, &check, &user_data))
    return NULL;

  if (check == Py_None)
    {
      region =
        vsg_prtree3@t@_find_deep_region (pyg_boxed_get (self, VsgPRTree3@t@),
                                         point, NULL, NULL);
    }
  else
    {
      FindDeepRegionData3@t@ marshaller_data = {check, user_data, TRUE};
      PyObject *test;
      VsgVector3@t@ testv = {0., 0., 0.};

      test = pyvsg_point3@t@_locfunc (point, &testv,
                                      pyg_boxed_get (self, VsgPRTree3@t@)->config.point_loc_data);

      if (test == NULL || !PyInt_Check (test))
        {
          PyErr_SetString(PyExc_ValueError,
                          "VsgPRTree3@t@.find_deep_region point " \
                          "argument must follow vsg.Point3 interface.");
          if (test != NULL) {Py_DECREF (test);}
          return NULL;
        }
      else
        {Py_DECREF (test);}


      if (! PyCallable_Check (check))
        {
          PyErr_SetString(PyExc_ValueError,
                          "VsgPRTree3@t@.find_deep_region check argument " \
                          "must be a callable type");
          return NULL;
        }

      region =
        vsg_prtree3@t@_find_deep_region (pyg_boxed_get (self, VsgPRTree3@t@),
                                         point,
                                         (VsgRegion3CheckFunc) _prtree3@t@_find_deep_region_marshall,
                                         &marshaller_data);

      if (marshaller_data.success == FALSE)
        {
          return NULL; /* an error occured */
        }
    }

  if (region == NULL)
    {
      Py_INCREF (Py_None);
      return Py_None;
    }

  Py_INCREF (region);
  return region;
}

/*****************************************************************************/
%%
override-slot VsgPRTree3@t@.tp_traverse

typedef struct _VisitStruct3@t@ VisitStruct3@t@;
struct _VisitStruct3@t@ {
  visitproc visit;
  void *arg;
  int ret;
};

static
void visitfunc3@t@ (PyObject *obj,
                    VisitStruct3@t@ *v)
{
  if (v->ret >= 0)
    {
      v->ret = v->visit (obj, v->arg);
    }
  /* else do nothing */
}

static int
_wrap_vsg_prtree3@t@_tp_traverse(PyObject *self, visitproc visit, void *arg)
{
  VsgPRTree3@t@ *tree = pyg_boxed_get (self, VsgPRTree3@t@);
  VisitStruct3@t@ v = {visit, arg, 0};

  if (tree->config.point_loc_data != NULL)
    {
      if (visit (tree->config.point_loc_data, arg) < 0) return -1;
    }

  if (tree->config.point_dist_data != NULL)
    {
      if (visit (tree->config.point_dist_data, arg) < 0) return -1;
    }

  if (tree->config.region_loc_data != NULL)
    {
      if (visit (tree->config.region_loc_data, arg) < 0) return -1;
    }

  if (tree->config.user_data_model != NULL)
    {
      if (visit (tree->config.user_data_model, arg) < 0) return -1;
    }

  vsg_prtree3@t@_foreach_point (tree, (GFunc) visitfunc3@t@, &v);
  if (v.ret < 0) return -1;

  vsg_prtree3@t@_foreach_region (tree, (GFunc) visitfunc3@t@, &v);
  if (v.ret < 0) return -1;

  return 0;
}

/*****************************************************************************/
%%
override-slot VsgPRTree3@t@.tp_clear

static
void clear_func3@t@ (PyObject *obj, gpointer user_data)
{
  Py_XDECREF(obj);
}

static int
_wrap_vsg_prtree3@t@_tp_clear(PyObject *self)
{
  VsgPRTree3@t@ *tree = pyg_boxed_get (self, VsgPRTree3@t@);

  Py_XDECREF((PyObject *) tree->config.point_loc_data);
  tree->config.point_loc_data = NULL;

  Py_XDECREF((PyObject *) tree->config.point_dist_data);
  tree->config.point_dist_data = NULL;

  Py_XDECREF((PyObject *) tree->config.region_loc_data);
  tree->config.region_loc_data = NULL;

  vsg_prtree3@t@_foreach_point (tree, (GFunc) clear_func3@t@, NULL);
  vsg_prtree3@t@_foreach_region (tree, (GFunc) clear_func3@t@, NULL);

  vsg_prtree3@t@_set_node_data (tree, G_TYPE_NONE, NULL);

  vsg_prtree3@t@_free (tree);

  return 0;
}

/*****************************************************************************/
%%
override-slot VsgPRTree3@t@.tp_dealloc

static void
_wrap_vsg_prtree3@t@_tp_dealloc(PyObject* self)
{
  _wrap_vsg_prtree3@t@_tp_clear(self);

  self->ob_type->tp_free(self);
}

/*****************************************************************************/
%%
override-attr VsgPRTree3@t@NodeInfo.point_list

static PyObject *
_wrap_vsg_prtree3@t@_node_info__get_point_list (PyObject *self,
                                                   void *closure)
{
  PyObject *pylist = PyList_New (0);
  PyObject *pypoint;

  GSList *point_list =
    pyg_boxed_get(self, VsgPRTree3@t@NodeInfo)->point_list;

  while (point_list != NULL)
    {
      pypoint = (PyObject *) point_list->data;

      PyList_Append (pylist, pypoint);

      point_list = g_slist_next (point_list);
    }
  return pylist;
}

/*****************************************************************************/
%%
override-attr VsgPRTree3@t@NodeInfo.region_list

static PyObject *
_wrap_vsg_prtree3@t@_node_info__get_region_list (PyObject *self,
                                                   void *closure)
{
  PyObject *pylist = PyList_New (0);
  PyObject *pyregion;

  GSList *region_list =
    pyg_boxed_get(self, VsgPRTree3@t@NodeInfo)->region_list;

  while (region_list != NULL)
    {
      pyregion = (PyObject *) region_list->data;

      PyList_Append (pylist, pyregion);

      region_list = g_slist_next (region_list);
    }
  return pylist;
}

/*****************************************************************************/
%%
override-attr VsgPRTree3@t@NodeInfo.user_data

static PyObject *
_wrap_vsg_prtree3@t@_node_info__get_user_data (PyObject *self,
                                                void *closure)
{
  PyObject *pyuser_data = (PyObject *)
    pyg_boxed_get(self, VsgPRTree3@t@NodeInfo)->user_data;
  pyuser_data = (pyuser_data != NULL) ? pyuser_data : Py_None;
  Py_INCREF (pyuser_data);
  return pyuser_data;
}

/*****************************************************************************/
%%
override-attr VsgPRTree3@t@NodeInfo.father_info

static PyObject *
_wrap_vsg_prtree3@t@_node_info__get_father_info(PyObject *self, void *closure)
{
    VsgPRTree3@t@NodeInfo *ret;

    ret = pyg_boxed_get(self, VsgPRTree3@t@NodeInfo)->father_info;
    /* pyg_boxed_new handles NULL checking */
    /* we don't hold any reference on father_info structure. */
    return pyg_boxed_new(VSG_TYPE_PRTREE3@T@_NODE_INFO, ret, FALSE, FALSE);
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_traverse

typedef struct _TraverseData3@t@ TraverseData3@t@;

struct _TraverseData3@t@
{
  PyObject *func;
  PyObject *user_data;
  gboolean success;
};

static void
_prtree3@t@_traverse_marshall (VsgPRTree3@t@NodeInfo *node_info,
                                TraverseData3@t@ *marshall_data)
{
  PyObject *pyinfo = pyg_boxed_new (VSG_TYPE_PRTREE3@T@_NODE_INFO, node_info,
                                    FALSE, FALSE);
  PyObject *args = PyTuple_New (2);
  PyObject *pyret;

  Py_INCREF (pyinfo); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 0, pyinfo);
  
  Py_INCREF (marshall_data->user_data); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 1, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->func, args);

  Py_DECREF (args);
  Py_DECREF (pyinfo);

  if (pyret == NULL)
    {
      /* an error occured */
      marshall_data->success = FALSE;
      return;
    }

  Py_DECREF (pyret);
}



static PyObject *
_wrap_vsg_prtree3@t@_traverse (PyObject *self, PyObject *args)
{
  PyObject *func, *user_data;
  gint order;
  TraverseData3@t@ marshall_data;

  if (!PyArg_ParseTuple(args, "iOO:VsgPRTree3@t@.traverse",
                        &order, &func, &user_data))
    return NULL;

  if (!PyCallable_Check (func))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse func argument " \
                      "must be a callable type");

      return NULL;
    }

  if (order != G_IN_ORDER && order != G_PRE_ORDER &&
      order != G_POST_ORDER)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse order argument " \
                      "must be one of vsg.G_IN_ORDER, vsg.G_PRE_ORDER " \
                      "or vsg.G_POST_ORDER");
      return NULL;
    }

  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  vsg_prtree3@t@_traverse (pyg_boxed_get (self, VsgPRTree3@t@),
                            order,
                            (VsgPRTree3@t@Func) _prtree3@t@_traverse_marshall,
                            &marshall_data);

  if (marshall_data.success == FALSE) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_traverse_custom

static PyObject *
_wrap_vsg_prtree3@t@_traverse_custom (PyObject *self, PyObject *args)
{
  PyObject *selector, *func, *user_data;
  gint order;
  TraverseData3@t@ marshall_data;
  PyObject *test;
  VsgVector3@t@ testv = {0., 0., 0.};

  if (!PyArg_ParseTuple(args, "iOOO:VsgPRTree3@t@.traverse",
                        &order, &selector, &func, &user_data))
    return NULL;

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data == NULL)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse_custom must be called on a tree " \
                      "that possesses a region_locfunc method.");
      return NULL;;
    }

  test = pyvsg_region3@t@_locfunc (selector, &testv,
                                  pyg_boxed_get (self, VsgPRTree3@t@)->config.region_loc_data);

  if (test == NULL || !PyInt_Check (test))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse_custom selector " \
                      "argument must follow " \
                      "vsg.Region3 interface.");
      if (test != NULL) {Py_DECREF (test);}
      return NULL;
    }
  else
    {Py_DECREF (test);}


  if (!PyCallable_Check (func))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse func argument " \
                      "must be a callable type");

      return NULL;
    }

  if (order != G_IN_ORDER && order != G_PRE_ORDER &&
      order != G_POST_ORDER)
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.traverse_custom order argument " \
                      "must be one of vsg.G_IN_ORDER, vsg.G_PRE_ORDER " \
                      "or vsg.G_POST_ORDER");
      return NULL;
    }

  marshall_data.func = func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  vsg_prtree3@t@_traverse_custom (pyg_boxed_get (self, VsgPRTree3@t@),
                                   order, selector,
                                   (VsgPRTree3@t@Func) _prtree3@t@_traverse_marshall,
                                   &marshall_data);

  if (marshall_data.success == FALSE) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_near_far_traversal

typedef struct _NearFar3@t@Data NearFar3@t@Data;
struct _NearFar3@t@Data
{
  PyObject *far_func;
  PyObject *near_func;
  PyObject *user_data;
  gboolean success;
};

static gboolean
_prtree3@t@_far_func_marshall (VsgPRTree3@t@NodeInfo *one_info,
                                VsgPRTree3@t@NodeInfo *other_info,
                                NearFar3@t@Data *marshall_data)
{
  PyObject *pyoneinfo = pyg_boxed_new (VSG_TYPE_PRTREE3@T@_NODE_INFO,
                                       one_info, FALSE, FALSE);
  PyObject *pyotherinfo = pyg_boxed_new (VSG_TYPE_PRTREE3@T@_NODE_INFO,
                                         other_info, FALSE, FALSE);
  PyObject *args = PyTuple_New (3);
  PyObject *pyret;
  gboolean ret;

  Py_INCREF (pyoneinfo); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 0, pyoneinfo);
  
  Py_INCREF (pyotherinfo); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 1, pyotherinfo);
  
  Py_INCREF (marshall_data->user_data); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 2, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->far_func, args);

  Py_DECREF (args);
  Py_DECREF (pyoneinfo);
  Py_DECREF (pyotherinfo);

  if (pyret == NULL)
    {
      /* an error occured */
      marshall_data->success = FALSE;
      return FALSE;
    }

  ret = PyObject_IsTrue (pyret);

  Py_DECREF (pyret);

  return ret;
}

static void
_prtree3@t@_near_func_marshall (VsgPRTree3@t@NodeInfo *one_info,
                                 VsgPRTree3@t@NodeInfo *other_info,
                                 NearFar3@t@Data *marshall_data)
{
  PyObject *pyoneinfo = pyg_boxed_new (VSG_TYPE_PRTREE3@T@_NODE_INFO,
                                       one_info, FALSE, FALSE);
  PyObject *pyotherinfo = pyg_boxed_new (VSG_TYPE_PRTREE3@T@_NODE_INFO,
                                         other_info, FALSE, FALSE);
  PyObject *args = PyTuple_New (3);
  PyObject *pyret;

  Py_INCREF (pyoneinfo); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 0, pyoneinfo);
  
  Py_INCREF (pyotherinfo); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 1, pyotherinfo);
  
  Py_INCREF (marshall_data->user_data); /* since tuple steals ref on items */
  PyTuple_SetItem (args, 2, marshall_data->user_data);

  pyret = PyObject_CallObject (marshall_data->near_func, args);

  Py_DECREF (args);
  Py_DECREF (pyoneinfo);
  Py_DECREF (pyotherinfo);

  if (pyret == NULL)
    {
      /* an error occured */
      marshall_data->success = FALSE;
      return;
    }

  Py_DECREF (pyret);

}

static PyObject *
_wrap_vsg_prtree3@t@_near_far_traversal (PyObject *self, PyObject *args)
{
  PyObject *far_func, *near_func, *user_data;
  NearFar3@t@Data marshall_data;

  if (!PyArg_ParseTuple(args, "OOO:VsgPRTree3@t@.near_far_traversal",
                        &far_func, &near_func, &user_data))
    return NULL;

  if (!PyCallable_Check (far_func))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.near_far_traversal far_func argument " \
                      "must be a callable type");

      return NULL;
    }

  if (!PyCallable_Check (near_func))
    {
      PyErr_SetString(PyExc_ValueError,
                      "VsgPRTree3@t@.near_far_traversal near_func argument " \
                      "must be a callable type");

      return NULL;
    }

  marshall_data.far_func = far_func;
  marshall_data.near_func = near_func;
  marshall_data.user_data = user_data;
  marshall_data.success = TRUE;

  vsg_prtree3@t@_near_far_traversal (pyg_boxed_get (self, VsgPRTree3@t@),
                                      (VsgPRTree3@t@FarInteractionFunc) _prtree3@t@_far_func_marshall,
                                      (VsgPRTree3@t@InteractionFunc) _prtree3@t@_near_func_marshall,
                                      &marshall_data);

  if (marshall_data.success == FALSE) return NULL;

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_set_node_data

static PyObject *
_wrap_vsg_prtree3@t@_set_node_data (PyObject *self, PyObject *args)
{
  PyObject *obj;
  GType type = PYVSG_TYPE_BOXED_PYOBJECT;

  if (!PyArg_ParseTuple(args, "O:VsgPRTree3@t@.set_node_data", &obj))
    return NULL;

  if (obj == Py_None)
    {
      type = G_TYPE_NONE;
      obj = NULL;
    }
  else
    {
      if (!pyvsg_boxed_pyobject_check_method (obj))
        {
          PyErr_SetString(PyExc_ValueError,
                          "VsgPRTree3t@.set_node_data argument " \
                          "must have a \"copy\" method");
          return NULL;
        }
    }

  vsg_prtree3@t@_set_node_data (pyg_boxed_get (self, VsgPRTree3@t@),
                                 type, obj);

  Py_INCREF (Py_None);
  return Py_None;
}

/*****************************************************************************/
%%
override vsg_prtree3@t@_clone noargs

static void _incref3@t@ (PyObject *obj, gpointer user_data)
{
  Py_INCREF (obj);
}

static PyObject *
_wrap_vsg_prtree3@t@_clone(PyObject *self)
{
  VsgPRTree3@t@ *ret;
  PyGBoxed *pyret;
  VsgPRTree3@t@ *tree = pyg_boxed_get (self, VsgPRTree3@t@);

  ret = vsg_prtree3@t@_clone (tree);

  vsg_prtree3@t@_foreach_point (ret, (GFunc) _incref3@t@, NULL);
  vsg_prtree3@t@_foreach_region (ret, (GFunc) _incref3@t@, NULL);

  Py_INCREF ((PyObject *) ret->config.point_loc_data);

  Py_INCREF ((PyObject *) ret->config.point_dist_data);

  Py_INCREF ((PyObject *) ret->config.region_loc_data);

  if (pyg_boxed_get (self, VsgPRTree3@t@)->config.children_order != NULL)
    {
      PyObject *func =
        pyg_boxed_get (self, VsgPRTree3@t@)->config.children_order_data;

      Py_INCREF (func);
    }

  pyret = PyObject_GC_New(PyGBoxed, &PyVsgPRTree3@t@_Type);

  pyret->boxed = ret;
  pyret->gtype = VSG_TYPE_PRTREE3@T@;
  pyret->free_on_dealloc = TRUE;

  return (PyObject *) pyret;
}

